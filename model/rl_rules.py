import logging
from copy import deepcopy
import itertools
import numpy as np
import random
from torch import tensor

card_path = '../data/cards.csv'
nobles_path = '../data/nobles.csv'


class Card:
    def __init__(self, id, data):
        # id: card ID, autogenerated
        # cost: array of ints representing the token cost of the card

        self.id = id
        self.tier = data[0]
        self.value = data[1]
        self.type = data[2] - 1
        self.cost = data[3:]

    def __repr__(self):
        return f"Card {self.id}, Tier: {self.tier}, Value: {self.value}, Type: {self.type}, Cost: {self.cost}"

    def serialize(self):
        return [self.value, self.type, *self.cost]


class Noble:
    def __init__(self, id, cost):
        # cost: array of ints representing total card cost for each type required to buy the noble
        self.id = id
        self.cost = cost
        self.points = 3

    def __str__(self):
        return f"ID: {self.id}, Cost: {self.cost}"

    def serialize(self):
        return [*self.cost, self.points]


class TokenBank:
    def __init__(self):
        self.tokens = [5] * 5

    def serialize(self):
        return self.tokens

    # update the tokens in the bank.
    def update(self, token_change, subtract=False):
        if subtract:
            token_change = [-x for x in token_change]
        self.tokens = [sum(x) for x in zip(self.tokens, token_change)]


class PlayerState:
    def __init__(self, id, turn_order):
        self.id = id
        self.turn_order = turn_order
        self.points = 0

        # Player inventory
        self.cards = []
        self.card_counts = [0, 0, 0, 0, 0]
        self.reserved_cards = []
        self.tokens = [0, 0, 0, 0, 0]
        self.nobles = []

    def __str__(self):
        return f"\nPlayer: {self.id}\nPoints: {self.points}\nTokens: {self.tokens}\nCards: {self.card_counts}"

    def __repr__(self):
        return f"Player({self.id}, {self.points}, {self.tokens}, {self.card_counts})"

    def serialize(self):
        return [
            *self.card_counts,
            self.points,
            *self.tokens,
        ]

    def updateNoble(self, noble: Noble):
        # used for updating points if player gets a noble 
        self.points += 3
        self.nobles.append(noble)

    def updateTokens(self, token_change, subtract=False):
        if subtract:
            token_change = [-x for x in token_change]
        self.tokens = [sum(x) for x in zip(self.tokens, token_change)]

    def updateCards(self, card: Card):
        self.cards.append(card)
        self.card_counts[card.type] += 1
        self.points += card.value


# Master class that controls the game
# 1. Control changes to board state
# 2. Controls changes to player state
class Board:

    token_options =  {
                0 : [2, 0, 0, 0, 0],
                1: [0, 2, 0, 0, 0],
                2: [0, 0, 2, 0, 0],
                3: [0, 0, 0, 2, 0],
                4: [0, 0, 0, 0, 2],
                5: [1, 1, 1, 0, 0],
                6: [1, 1, 0, 1, 0],
                7: [1, 1, 0, 0, 1],
                8: [1, 0, 1, 1, 0],
                9: [1, 0, 1, 0, 1],
                10: [1, 0, 0, 1, 1],
                11: [0, 1, 1, 1, 0],
                12: [0, 1, 1, 0, 1],
                13: [0, 1, 0, 1, 1],
                14: [0, 0, 1, 1, 1],
                15: [0, 0, 0, 0, 0],
                # stupid workaround: let players pass
                }

    def __init__(self):
        self.all_cards, self.all_nobles = self._read_data()
        self.open_cards : list[list[Card]] = [[],[],[]]
        self.deck_cards : list[list[Card]] = [[],[],[]]
        self.nobles : list[Noble] = []

        self.bank = TokenBank()
        self.player1 = PlayerState(id=0, turn_order=0)
        self.player2 = PlayerState(id=1,turn_order=1)
        self.list_players = [self.player1, self.player2]
        self.cycle_players = itertools.cycle(self.list_players)
        self.current_player = next(self.cycle_players)
        self.turn = 1
        self.points_to_win = 15

        # Init board state
        # split cards into tier decks
        for card in self.all_cards:
            self.deck_cards[card.tier - 1].append(card)

        # draw 4 cards per tier, add to open_cards
        for tier in range(3):
            self._draw_cards(tier, 4)

        # choose 3 nobles
        for i in range(3):
            idx = random.randint(0, len(self.all_nobles) - 1)
            self.nobles.append(self.all_nobles.pop(idx))

        logging.info(f'Round {self.turn}: Start')

    def getState(self):
        # returns 1d list of board states
        # 12 open cards (12, 7), 3 nobles (3, 6), player1 (1, 11), player2 (1, 11), bank (1, 5)
        dims = (12 * 7) + (3 * 6) + (2 * 11) + 5
        data = np.zeros(dims)
        cards_state = np.zeros((12 * 7))
        nobles_state = np.zeros((3 * 6))
        players_state = np.zeros(22)
        bank_state = np.zeros(5)

        idx = 0
        for tier in self.open_cards:
            for card in tier:
                cards_state[idx : idx+7] = card.serialize()
                idx += 7

        idx = 0
        for noble in self.nobles:
            nobles_state[idx : idx+6] = noble.serialize()
            idx += 6
        
        idx = 0
        for player in self.list_players:
            players_state[idx : idx + 11] = player.serialize()
            idx += 11

        bank_state[:] = self.bank.serialize()

        data = np.concatenate((cards_state, nobles_state, players_state, bank_state))

        return tensor(data).float()
        
    def playerAction(self, action_index):
        # action index is a number between 0 to 12+16=28
        # assert(self.can_take_action(action_index))
        reward = 0
        if action_index in range(0, 12):
            # Player buys a card, 9 ways
            row = action_index // 4
            col = action_index  % 4

            if col in range(len(self.open_cards[row])):
                card = self.open_cards[row].pop(col)
                reward = card.value

                cost = [max(card_cost - card_counts, 0)
                        for card_cost, card_counts in zip(card.cost, self.current_player.card_counts)]

                # Update player states
                self.current_player.updateCards(card)
                self.current_player.updateTokens(cost, subtract=True)

                # Update board states
                self._draw_cards(row, 1)
                self.bank.update(cost)

        elif action_index in range(12, 28):
            # Player takes a token, 15 ways
            reward = 1
            idx = action_index - 12

            tokens = self.token_options[idx]
            self.current_player.updateTokens(tokens)
            self.bank.update(tokens, subtract=True)

        # at the end of player action, check nobles
        self._check_nobles()
        check_winner = self._end_player()
        if check_winner:
            reward = 3 if check_winner == self.list_players[0] else -1 # always favour player 0
        done = True if check_winner else False
        return reward, done

    def can_take_tokens(self, request_tokens):
        return all(request_token <= bank_token and ((request_token < 2) or (bank_token >= 4))
                   for request_token, bank_token in zip(request_tokens, self.bank.tokens))

    def can_buy_card(self, player: PlayerState, card: Card):
        # doesn't work with gold tokens
        return all(cost_token - player_card <= player_token
                   for player_token, player_card, cost_token in zip(player.tokens, player.card_counts, card.cost))

    def can_take_action(self, action_index):
        if action_index in range(0, 12):
            # Player buys a card, 9 ways
            row = action_index // 4
            col = action_index % 4
            return len(self.open_cards[row]) > col and self.can_buy_card(self.current_player, self.open_cards[row][col])

        elif action_index in range(12, 28):
            # Player takes a token, 15 ways
            idx = action_index - 12
            return self.can_take_tokens(self.token_options[idx])

    def possible_actions(self):
        return [action for action in range(28) if self.can_take_action(action)]

    def possible_actions_mask(self):
        return [int(self.can_take_action(action)) for action in range(28)]

    def human_action_description(self, action):
        if action < 12:
            return f"Buy card {self.open_cards[action//4][action%4]}"
        elif action < 28:
            return f"Take tokens {self.token_options[action-12]}"

    def _read_data(self):
        temp_cards = np.genfromtxt(card_path, dtype=np.int32, delimiter=',', skip_header=1).tolist()
        temp_nobles = np.genfromtxt(nobles_path, dtype=np.int32, delimiter=',', skip_header=1).tolist()

        cards = []
        for i in range(len(temp_cards)):
            c = Card(i, temp_cards[i])
            cards.append(c)

        nobles = []
        for i in range(len(temp_nobles)):
            n = Noble(i, temp_nobles[i])
            nobles.append(n)

        return cards, nobles

    def _draw_cards(self, tier, num_cards):
        # remove cards from the specified tier deck and add to list of open cards
        idx = 0
        cards = []

        if len(self.deck_cards[tier]) - 1 <= 0:
            return False

        for i in range(num_cards):
            idx = random.randint(0, len(self.deck_cards[tier]) - 1)
            card = self.deck_cards[tier].pop(idx)
            cards.append(card)

        self.open_cards[tier].extend(cards)

    def _check_nobles(self):
        # check if current player can be visited by noble
        for noble in self.nobles:
            if all(card_count >= cost for card_count, cost in zip(self.current_player.card_counts, noble.cost)):
                self.current_player.updateNoble(noble)
                self.nobles.remove(noble)

    def _end_player(self):
        # check for win condition, return player
        if self.current_player.points >= self.points_to_win:
            logging.info(f'Player {self.current_player.id} has won! {self.current_player.points} points!')
            return self.current_player
        else:
            if self.current_player.id == self.list_players[-1].id:
                self.turn += 1
                logging.info(f'Round {self.turn}: Start')
                logging.info(f'Player 0: {self.list_players[0].points} points\tPlayer 1: {self.list_players[1].points} points')
            self.current_player = next(self.cycle_players)
            logging.info(f'Player {self.current_player.id} Action: {self.current_player.serialize()}')

    def __str__(self):
        return f"Players: {self.list_players}\nCards: {self.open_cards}\nTokens: {self.bank.tokens}"

        
